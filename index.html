<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Kinetic Particles (Debug Version)</title>
  
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/@babel/standalone@7.23.6/babel.min.js"></script>

  <style>
    body { margin: 0; overflow: hidden; background: #050505; color: white; }
    canvas { width: 100vw; height: 100vh; display: block; }
    #error-log { position: absolute; top: 0; left: 0; width: 100%; background: rgba(255,0,0,0.8); color: white; padding: 20px; z-index: 9999; display: none; }
    .loader { border: 4px solid #f3f3f3; border-top: 4px solid #06b6d4; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
  </style>

  <script>
    window.onerror = function(msg, url, line) {
      const log = document.getElementById('error-log');
      log.style.display = 'block';
      log.innerHTML += `<strong>ERROR:</strong> ${msg}<br><small>${url}:${line}</small><br><br>`;
      return false;
    };
  </script>

  <script type="importmap">
  {
    "imports": {
      "react": "https://esm.sh/react@18.2.0",
      "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
      "three": "https://esm.sh/three@0.160.0",
      "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.14?external=react,react-dom,three",
      "@react-three/drei": "https://esm.sh/@react-three/drei@9.96.1?external=react,react-dom,three,@react-three/fiber",
      "@mediapipe/tasks-vision": "https://esm.sh/@mediapipe/tasks-vision@0.10.8"
    }
  }
  </script>
</head>
<body>
  <div id="error-log"></div>
  <div id="root"></div>

  <script type="text/babel" data-presets="react,typescript">
    import React, { useState, useCallback, useEffect, useRef, useMemo } from 'react';
    import { createRoot } from 'react-dom/client';
    import { Canvas, useFrame } from '@react-three/fiber';
    import { OrbitControls, Stars, PerspectiveCamera } from '@react-three/drei';
    import * as THREE from 'three';
    import { FilesetResolver, HandLandmarker } from "@mediapipe/tasks-vision";

    console.log("Iniciando aplicación...");

    // 1. CONSTANTS & TYPES
    enum ShapeType {
      HEART = 'Heart',
      FLOWER = 'Flower',
      SATURN = 'Saturn',
      MEDITATING = 'Meditating',
      FIREWORKS = 'Fireworks',
      SPHERE = 'Sphere'
    }

    // 2. LOGIC FOR LOCAL AI
    const calculateOpenness = (landmarks) => {
        const wrist = landmarks[0];
        const tips = [4, 8, 12, 16, 20];
        let totalDist = 0;
        tips.forEach(idx => {
            const tip = landmarks[idx];
            const dist = Math.sqrt(Math.pow(tip.x - wrist.x, 2) + Math.pow(tip.y - wrist.y, 2));
            totalDist += dist;
        });
        const avgDist = totalDist / 5;
        const openness = (avgDist - 0.1) / (0.35 - 0.1); 
        return Math.max(0, Math.min(1, openness));
    };

    // 3. COMPONENTS
    const COUNT = 3000; // Reducido un poco para asegurar carga rápida
    const DUMMY = new THREE.Object3D();

    const getPosition = (i, shape) => {
      const p = new THREE.Vector3();
      const ratio = i / COUNT;
      switch (shape) {
        case ShapeType.SPHERE:
          const theta = Math.acos(THREE.MathUtils.randFloatSpread(2));
          const phi = THREE.MathUtils.randFloatSpread(360);
          p.setFromSphericalCoords(10, theta, phi);
          break;
        case ShapeType.HEART:
          const t = ratio * Math.PI * 2 * 10;
          const x = 16 * Math.pow(Math.sin(t), 3);
          const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
          p.set(x * 0.5, y * 0.5, (Math.random() - 0.5) * 5);
          break;
        case ShapeType.FLOWER:
           const k = 4; const thetaF = ratio * Math.PI * 2 * 20; const r = Math.cos(k * thetaF) * 10;
           p.set(r * Math.cos(thetaF), r * Math.sin(thetaF), (Math.random() - 0.5) * 5);
           break;
        default: // Fallback simple sphere
           p.setFromSphericalCoords(10, Math.random() * Math.PI, Math.random() * Math.PI * 2);
      }
      return p;
    };

    const ParticleSystem = ({ shape, expansion, tension, color }) => {
      const meshRef = useRef(null);
      const basePositions = useMemo(() => {
        const positions = new Float32Array(COUNT * 3);
        for (let i = 0; i < COUNT; i++) {
          const v = getPosition(i, shape);
          positions[i * 3] = v.x; positions[i * 3 + 1] = v.y; positions[i * 3 + 2] = v.z;
        }
        return positions;
      }, [shape]);

      const particles = useMemo(() => new Array(COUNT).fill(0).map(() => ({ offset: Math.random() * 100 })), []);

      useFrame((state) => {
        if (!meshRef.current) return;
        const time = state.clock.getElapsedTime();
        const expandFactor = 1 + expansion * 2.5;
        const tensionFactor = tension * 2;

        for (let i = 0; i < COUNT; i++) {
          const ix = i * 3;
          let x = basePositions[ix] * expandFactor;
          let y = basePositions[ix + 1] * expandFactor;
          let z = basePositions[ix + 2] * expandFactor;
          
          const noise = Math.sin(time * 5 + particles[i].offset) * (tensionFactor * 0.5);
          x += noise; y += noise; z += noise;

          DUMMY.position.set(x, y, z);
          const s = (1 + Math.sin(time * 2 + particles[i].offset) * 0.3) * (0.5 + expansion * 0.5);
          DUMMY.scale.set(s, s, s);
          DUMMY.updateMatrix();
          meshRef.current.setMatrixAt(i, DUMMY.matrix);
        }
        meshRef.current.instanceMatrix.needsUpdate = true;
      });

      return (
        <instancedMesh ref={meshRef} args={[undefined, undefined, COUNT]}>
          <sphereGeometry args={[0.1, 5, 5]} />
          <meshStandardMaterial color={color} emissive={color} emissiveIntensity={0.8 + tension * 2} toneMapped={false} />
        </instancedMesh>
      );
    };

    const Controls = ({ currentShape, setShape, color, setColor, aiState, isModelLoading }) => {
       return (
        <div className="absolute top-0 left-0 w-full h-full pointer-events-none p-6 flex flex-col justify-between z-10">
          <div className="flex justify-between items-start pointer-events-auto">
             <div>
               <h1 className="text-2xl font-bold text-cyan-400">KINETIC PARTICLES</h1>
               <p className="text-xs text-gray-400">Local AI Version</p>
             </div>
             <div className="bg-gray-900/80 p-2 rounded border border-white/20">
               {isModelLoading ? <div className="loader"></div> : <span className="text-green-400 text-xs">● AI READY</span>}
             </div>
          </div>
          <div className="pointer-events-auto flex gap-2">
             {Object.values(ShapeType).slice(0,3).map(s => (
               <button key={s} onClick={() => setShape(s)} className="bg-white/10 text-white px-3 py-1 rounded text-xs hover:bg-white/30 border border-white/20">{s}</button>
             ))}
          </div>
        </div>
       )
    }

    const LocalVisionHandler = ({ onUpdate, onLoadChange }) => {
      const videoRef = useRef(null);
      const handLandmarkerRef = useRef(null);
      const requestRef = useRef(null);

      useEffect(() => {
        const start = async () => {
          try {
            console.log("Cargando MediaPipe...");
            onLoadChange(true);
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm");
            handLandmarkerRef.current = await HandLandmarker.createFromOptions(vision, {
              baseOptions: {
                modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                delegate: "GPU"
              },
              runningMode: "VIDEO",
              numHands: 1
            });
            console.log("MediaPipe cargado. Iniciando cámara...");

            const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
            if (videoRef.current) {
               videoRef.current.srcObject = stream;
               videoRef.current.addEventListener('loadeddata', predict);
            }
          } catch (e) {
            console.error("Error fatal en IA:", e);
            alert("Error al cargar la IA o Cámara: " + e.message);
          } finally {
            onLoadChange(false);
          }
        };
        start();
        return () => { if(requestRef.current) cancelAnimationFrame(requestRef.current); }
      }, []);

      const predict = async () => {
         if (videoRef.current && handLandmarkerRef.current) {
             const now = performance.now();
             const result = handLandmarkerRef.current.detectForVideo(videoRef.current, now);
             if (result.landmarks && result.landmarks.length > 0) {
                 const openness = calculateOpenness(result.landmarks[0]);
                 onUpdate({ expansion: openness, tension: 0.5 }); // Simplificado para debug
             } else {
                 onUpdate(prev => ({ expansion: prev.expansion * 0.9, tension: 0 }));
             }
         }
         requestRef.current = requestAnimationFrame(predict);
      }

      return <video ref={videoRef} autoPlay playsInline muted className="hidden" />;
    };

    const App = () => {
      const [shape, setShape] = useState(ShapeType.HEART);
      const [aiState, setAiState] = useState({ expansion: 0.5, tension: 0 });
      const [loading, setLoading] = useState(true);

      return (
        <div className="relative w-full h-screen bg-black">
          <LocalVisionHandler onUpdate={setAiState} onLoadChange={setLoading} />
          <Controls currentShape={shape} setShape={setShape} aiState={aiState} isModelLoading={loading} />
          <Canvas>
            <PerspectiveCamera makeDefault position={[0, 0, 30]} fov={60} />
            <ambientLight intensity={0.5} />
            <pointLight position={[10, 10, 10]} intensity={1} />
            <ParticleSystem shape={shape} color="#ec4899" expansion={aiState.expansion} tension={aiState.tension} />
            <OrbitControls autoRotate />
          </Canvas>
        </div>
      );
    };

    const root = createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
