<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Galaxy Control - Minority Report Style</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1632432234/camera_utils.js" crossorigin="anonymous"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      font-family: "SF Pro Display", -apple-system, BlinkMacSystemFont, sans-serif;
      background: #000;
      cursor: none;
    }

    #three-container {
      position: absolute;
      inset: 0;
      z-index: 1;
    }

    /* Hand cursor visualization on screen */
    .hand-cursor {
      position: fixed;
      width: 30px;
      height: 30px;
      border: 2px solid rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      pointer-events: none;
      z-index: 100;
      transform: translate(-50%, -50%);
      transition: all 0.05s ease-out;
      display: none;
    }

    .hand-cursor.left {
      border-color: #ff6b9d;
      box-shadow: 0 0 20px #ff6b9d, 0 0 40px #ff6b9d40, inset 0 0 15px #ff6b9d40;
    }

    .hand-cursor.right {
      border-color: #6bffb8;
      box-shadow: 0 0 20px #6bffb8, 0 0 40px #6bffb840, inset 0 0 15px #6bffb840;
    }

    .hand-cursor.grabbing {
      transform: translate(-50%, -50%) scale(0.7);
      background: rgba(255, 255, 255, 0.3);
    }

    .hand-cursor::after {
      content: '';
      position: absolute;
      inset: -10px;
      border: 1px solid currentColor;
      border-radius: 50%;
      opacity: 0.3;
    }

    /* Connection line between hands */
    #hand-connection {
      position: fixed;
      height: 2px;
      background: linear-gradient(90deg, #ff6b9d, #6bffb8);
      pointer-events: none;
      z-index: 99;
      transform-origin: left center;
      display: none;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }

    .panel {
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .top-panel {
      position: absolute;
      top: 24px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      padding: 16px 32px;
      text-align: center;
    }

    .top-panel h1 {
      font-size: 24px;
      font-weight: 300;
      color: #ffffff;
      letter-spacing: 0.2em;
      text-transform: uppercase;
    }

    .top-panel .gesture-mode {
      margin-top: 8px;
      font-size: 14px;
      color: #6bffb8;
      font-weight: 500;
      min-height: 20px;
    }

    .right-panel {
      position: absolute;
      top: 24px;
      right: 24px;
      z-index: 10;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .camera-btn {
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: 16px;
      padding: 16px 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 12px;
      transition: all 0.3s ease;
    }

    .camera-btn.inactive {
      background: linear-gradient(135deg, rgba(107, 255, 184, 0.3), rgba(107, 255, 184, 0.1));
      border: 1px solid rgba(107, 255, 184, 0.5);
    }

    .camera-btn.active {
      background: linear-gradient(135deg, rgba(255, 107, 107, 0.3), rgba(255, 107, 107, 0.1));
      border: 1px solid rgba(255, 107, 107, 0.5);
    }

    .camera-btn.loading {
      cursor: wait;
      opacity: 0.7;
    }

    .camera-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .camera-indicator.inactive {
      background: #6bffb8;
      box-shadow: 0 0 12px #6bffb8;
    }

    .camera-indicator.active {
      background: #ff6b6b;
      box-shadow: 0 0 12px #ff6b6b;
      animation: pulse 2s infinite;
    }

    .camera-btn span {
      color: #ffffff;
      font-size: 14px;
      font-weight: 500;
    }

    .camera-preview {
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(20px);
      border-radius: 16px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.1);
      position: relative;
      display: none;
    }

    .camera-preview.visible {
      display: block;
    }

    #video { display: none; }

    #canvas {
      width: 280px;
      height: 210px;
      display: block;
    }

    .camera-status {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 12px 16px;
      background: linear-gradient(transparent, rgba(0, 0, 0, 0.9));
    }

    .camera-status p {
      margin: 0;
      font-size: 11px;
      color: rgba(255, 255, 255, 0.7);
      font-weight: 500;
    }

    /* Instructions panel */
    .instructions {
      position: absolute;
      bottom: 24px;
      left: 24px;
      z-index: 10;
      padding: 20px;
      max-width: 320px;
    }

    .instructions h3 {
      font-size: 11px;
      font-weight: 600;
      color: rgba(255, 255, 255, 0.4);
      text-transform: uppercase;
      letter-spacing: 0.15em;
      margin-bottom: 16px;
    }

    .gesture-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .gesture-item {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .gesture-icon {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
    }

    .gesture-info {
      flex: 1;
    }

    .gesture-name {
      font-size: 13px;
      color: #ffffff;
      font-weight: 500;
    }

    .gesture-desc {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.5);
      margin-top: 2px;
    }

    /* Stats panel */
    .stats-panel {
      position: absolute;
      bottom: 24px;
      right: 24px;
      z-index: 10;
      padding: 20px;
      min-width: 200px;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
    }

    .stat-row:last-child {
      border-bottom: none;
    }

    .stat-label {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.4);
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }

    .stat-value {
      font-size: 14px;
      color: #ffffff;
      font-weight: 500;
      font-variant-numeric: tabular-nums;
    }

    .stat-value.highlight {
      color: #6bffb8;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #ffffff;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }

    /* Particle trail effect */
    .particle-trail {
      position: fixed;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      pointer-events: none;
      z-index: 98;
      opacity: 0;
    }
  </style>
</head>
<body>
  <div id="three-container"></div>
  
  <!-- Hand cursors -->
  <div id="left-cursor" class="hand-cursor left"></div>
  <div id="right-cursor" class="hand-cursor right"></div>
  <div id="hand-connection"></div>

  <!-- Top Panel -->
  <div class="panel top-panel">
    <h1>Galaxy Control</h1>
    <div class="gesture-mode" id="gesture-mode">Activa la c√°mara para comenzar</div>
  </div>

  <!-- Right Panel -->
  <div class="right-panel">
    <button id="camera-btn" class="camera-btn inactive">
      <div class="camera-indicator inactive"></div>
      <span>Iniciar C√°mara</span>
    </button>

    <div id="camera-preview" class="camera-preview">
      <video id="video" playsinline></video>
      <canvas id="canvas" width="280" height="210"></canvas>
      <div class="camera-status">
        <p id="hand-status">Buscando manos...</p>
      </div>
    </div>
  </div>

  <!-- Density Panel -->
  <div class="panel density-panel" style="position: absolute; top: 24px; left: 24px; z-index: 10; padding: 16px; min-width: 200px;">
    <div style="display: flex; justify-content: space-between; margin-bottom: 12px;">
      <span class="stat-label">Densidad</span>
      <span class="stat-value" id="density-value">5,000</span>
    </div>
    <input type="range" id="density-slider" min="1000" max="15000" step="1000" value="5000" style="width: 100%; height: 4px; border-radius: 2px; appearance: none; -webkit-appearance: none; background: rgba(255,255,255,0.1); cursor: pointer;">
  </div>

  <!-- Instructions -->
  <div class="panel instructions">
    <h3>Gestos disponibles</h3>
    <div class="gesture-list">
      <div class="gesture-item">
        <div class="gesture-icon">‚úã</div>
        <div class="gesture-info">
          <div class="gesture-name">Mano abierta</div>
          <div class="gesture-desc">Mueve la galaxia en X/Y</div>
        </div>
      </div>
      <div class="gesture-item">
        <div class="gesture-icon">‚úä</div>
        <div class="gesture-info">
          <div class="gesture-name">Pu√±o cerrado</div>
          <div class="gesture-desc">Rota la galaxia</div>
        </div>
      </div>
      <div class="gesture-item">
        <div class="gesture-icon">ü§è</div>
        <div class="gesture-info">
          <div class="gesture-name">Gesto pinza</div>
          <div class="gesture-desc">Zoom in/out (acercar/alejar)</div>
        </div>
      </div>
      <div class="gesture-item">
        <div class="gesture-icon">üôå</div>
        <div class="gesture-info">
          <div class="gesture-name">Dos manos</div>
          <div class="gesture-desc">Escala y controla profundidad</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Stats Panel -->
  <div class="panel stats-panel">
    <div class="stat-row">
      <span class="stat-label">Posici√≥n X</span>
      <span class="stat-value" id="stat-x">0.00</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">Posici√≥n Y</span>
      <span class="stat-value" id="stat-y">0.00</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">Posici√≥n Z</span>
      <span class="stat-value" id="stat-z">0.00</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">Rotaci√≥n</span>
      <span class="stat-value" id="stat-rot">0¬∞</span>
    </div>
    <div class="stat-row">
      <span class="stat-label">Escala</span>
      <span class="stat-value highlight" id="stat-scale">1.00√ó</span>
    </div>
  </div>

  <script>
    // Generate galaxy particles
    function generateGalaxy(count) {
      const positions = [];
      const colors = [];
      const arms = 4;
      
      for (let i = 0; i < count; i++) {
        const arm = i % arms;
        const progress = (i / count) * 5;
        const angle = (arm / arms) * Math.PI * 2 + progress * 2;
        const radius = progress * 0.7 + Math.random() * 0.4;
        
        const x = Math.cos(angle) * radius + (Math.random() - 0.5) * 0.3;
        const z = Math.sin(angle) * radius + (Math.random() - 0.5) * 0.3;
        const y = (Math.random() - 0.5) * 0.2 * (1 - progress / 5);
        
        positions.push(x, y, z);
        
        // More vibrant color gradient - pink/magenta center to cyan/blue edges
        const t = Math.min(radius / 3, 1);
        colors.push(
          1.0 - t * 0.3,           // R: high throughout
          0.4 + t * 0.6,           // G: increases outward
          0.7 + t * 0.3            // B: high throughout
        );
      }
      
      // Add central bright core - more particles
      const coreCount = Math.floor(count * 0.15);
      for (let i = 0; i < coreCount; i++) {
        const phi = Math.acos(2 * Math.random() - 1);
        const theta = Math.random() * Math.PI * 2;
        const r = Math.random() * 0.5;
        
        positions.push(
          r * Math.sin(phi) * Math.cos(theta),
          r * Math.sin(phi) * Math.sin(theta) * 0.3,
          r * Math.cos(phi)
        );
        
        // Bright white/pink core
        colors.push(1.0, 0.85, 0.95);
      }
      
      return { positions, colors };
    }

    // State
    let scene, camera, renderer, particles, starField;
    let particleCount = 5000;
    let cameraActive = false;
    let handsInstance = null;
    let cameraInstance = null;

    // Transform state
    const transform = {
      position: { x: 0, y: 0, z: 0 },
      rotation: { x: 0, y: 0 },
      scale: 1,
      autoRotate: true
    };

    // Target values for smooth interpolation
    const target = {
      position: { x: 0, y: 0, z: 0 },
      rotation: { x: 0, y: 0 },
      scale: 1
    };

    // Previous hand positions for velocity calculation
    let prevHandPos = { left: null, right: null };
    let currentGesture = 'none';

    // DOM Elements
    const container = document.getElementById('three-container');
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const cameraBtn = document.getElementById('camera-btn');
    const cameraPreview = document.getElementById('camera-preview');
    const handStatusEl = document.getElementById('hand-status');
    const gestureModeEl = document.getElementById('gesture-mode');
    const leftCursor = document.getElementById('left-cursor');
    const rightCursor = document.getElementById('right-cursor');
    const handConnection = document.getElementById('hand-connection');

    // Stats elements
    const statX = document.getElementById('stat-x');
    const statY = document.getElementById('stat-y');
    const statZ = document.getElementById('stat-z');
    const statRot = document.getElementById('stat-rot');
    const statScale = document.getElementById('stat-scale');
    const densitySlider = document.getElementById('density-slider');
    const densityValueEl = document.getElementById('density-value');

    // Initialize Three.js
    function initThreeJS() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setClearColor(0x000508, 1);
      container.appendChild(renderer.domElement);

      camera.position.z = 8;

      // Create starfield background
      createStarField();

      window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      });
    }

    function createStarField() {
      const starsGeometry = new THREE.BufferGeometry();
      const starCount = 2000;
      const positions = new Float32Array(starCount * 3);
      
      for (let i = 0; i < starCount * 3; i += 3) {
        positions[i] = (Math.random() - 0.5) * 100;
        positions[i + 1] = (Math.random() - 0.5) * 100;
        positions[i + 2] = (Math.random() - 0.5) * 100;
      }
      
      starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      const starsMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.1,
        transparent: true,
        opacity: 0.8
      });
      
      starField = new THREE.Points(starsGeometry, starsMaterial);
      scene.add(starField);
    }

    // Create Galaxy Particles
    function createParticles() {
      if (particles) {
        scene.remove(particles);
        particles.geometry.dispose();
        particles.material.dispose();
      }

      const { positions, colors } = generateGalaxy(particleCount);
      const totalCount = positions.length / 3;

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));

      const sizes = new Float32Array(totalCount);
      for (let i = 0; i < totalCount; i++) {
        sizes[i] = Math.random() * 0.8 + 0.4;
      }
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

      const material = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uScale: { value: 1 }
        },
        vertexShader: `
          attribute float size;
          attribute vec3 customColor;
          varying vec3 vColor;
          varying float vAlpha;
          uniform float uTime;
          uniform float uScale;
          
          void main() {
            vColor = customColor;
            vAlpha = 0.8 + sin(uTime * 2.0 + position.x * 5.0) * 0.2;
            
            vec3 pos = position * uScale;
            pos.x += sin(uTime + position.z * 2.0) * 0.03;
            pos.y += cos(uTime + position.x * 2.0) * 0.03;
            
            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = size * (350.0 / -mvPosition.z) * uScale;
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          varying vec3 vColor;
          varying float vAlpha;
          
          void main() {
            float dist = length(gl_PointCoord - vec2(0.5));
            if (dist > 0.5) discard;
            
            float glow = 1.0 - smoothstep(0.0, 0.5, dist);
            glow = pow(glow, 1.2);
            
            vec3 finalColor = vColor * (1.2 + glow * 0.8);
            gl_FragColor = vec4(finalColor, glow * vAlpha);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });

      particles = new THREE.Points(geometry, material);
      scene.add(particles);
    }

    // Animation Loop
    function animate() {
      if (!particles) {
        requestAnimationFrame(animate);
        return;
      }

      particles.material.uniforms.uTime.value += 0.005;

      // Smooth interpolation
      const lerp = 0.08;
      transform.position.x += (target.position.x - transform.position.x) * lerp;
      transform.position.y += (target.position.y - transform.position.y) * lerp;
      transform.position.z += (target.position.z - transform.position.z) * lerp;
      transform.scale += (target.scale - transform.scale) * lerp;
      
      // Rotation with momentum
      transform.rotation.x += (target.rotation.x - transform.rotation.x) * lerp;
      transform.rotation.y += (target.rotation.y - transform.rotation.y) * lerp;

      // Auto rotation when not interacting
      if (transform.autoRotate && currentGesture === 'none') {
        target.rotation.y += 0.003;
      }

      // Apply transforms
      particles.position.set(transform.position.x, transform.position.y, transform.position.z);
      particles.rotation.set(transform.rotation.x, transform.rotation.y, 0);
      particles.material.uniforms.uScale.value = transform.scale;

      // Update stars
      if (starField) {
        starField.rotation.y += 0.0001;
      }

      // Update stats
      statX.textContent = transform.position.x.toFixed(2);
      statY.textContent = transform.position.y.toFixed(2);
      statZ.textContent = transform.position.z.toFixed(2);
      statRot.textContent = Math.round((transform.rotation.y * 180 / Math.PI) % 360) + '¬∞';
      statScale.textContent = transform.scale.toFixed(2) + '√ó';

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // Gesture Detection
    function detectGesture(landmarks) {
      const dominated = landmarks[0];
      const thumb = landmarks[4];
      const index = landmarks[8];
      const middle = landmarks[12];
      const ring = landmarks[16];
      const pinky = landmarks[20];
      
      // Calculate finger extensions
      const thumbDist = distance(thumb, landmarks[2]);
      const indexDist = distance(index, landmarks[5]);
      const middleDist = distance(middle, landmarks[9]);
      const ringDist = distance(ring, landmarks[13]);
      const pinkyDist = distance(pinky, landmarks[17]);
      
      const fingerThreshold = 0.08;
      
      const thumbExtended = thumbDist > fingerThreshold;
      const indexExtended = indexDist > fingerThreshold;
      const middleExtended = middleDist > fingerThreshold;
      const ringExtended = ringDist > fingerThreshold;
      const pinkyExtended = pinkyDist > fingerThreshold;
      
      // Pinch detection (thumb and index close)
      const pinchDist = distance(thumb, index);
      const isPinching = pinchDist < 0.05;
      
      // Fist detection (all fingers closed)
      const extendedCount = [indexExtended, middleExtended, ringExtended, pinkyExtended].filter(Boolean).length;
      const isFist = extendedCount <= 1 && !isPinching;
      
      // Open hand (most fingers extended)
      const isOpen = extendedCount >= 3;
      
      if (isPinching) return 'pinch';
      if (isFist) return 'fist';
      if (isOpen) return 'open';
      
      return 'neutral';
    }

    function distance(p1, p2) {
      return Math.sqrt(
        Math.pow(p1.x - p2.x, 2) + 
        Math.pow(p1.y - p2.y, 2) + 
        Math.pow(p1.z - p2.z, 2)
      );
    }

    function distance2D(p1, p2) {
      return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
    }

    // Process hand data
    function processHands(results) {
      const hands = results.multiHandLandmarks;
      const handedness = results.multiHandedness;
      
      if (!hands || hands.length === 0) {
        currentGesture = 'none';
        leftCursor.style.display = 'none';
        rightCursor.style.display = 'none';
        handConnection.style.display = 'none';
        gestureModeEl.textContent = 'Muestra tus manos a la c√°mara';
        transform.autoRotate = true;
        return;
      }

      transform.autoRotate = false;
      
      // Sort hands by handedness
      let leftHand = null;
      let rightHand = null;
      
      hands.forEach((hand, idx) => {
        const label = handedness[idx]?.label;
        // Mirror: left appears as right in camera
        if (label === 'Right') leftHand = hand;
        else rightHand = hand;
      });

      // Update cursors
      if (leftHand) {
        const palm = leftHand[9]; // Middle finger base as palm center
        const screenX = (1 - palm.x) * window.innerWidth;
        const screenY = palm.y * window.innerHeight;
        leftCursor.style.left = screenX + 'px';
        leftCursor.style.top = screenY + 'px';
        leftCursor.style.display = 'block';
        
        const gesture = detectGesture(leftHand);
        leftCursor.classList.toggle('grabbing', gesture === 'fist' || gesture === 'pinch');
      } else {
        leftCursor.style.display = 'none';
      }

      if (rightHand) {
        const palm = rightHand[9];
        const screenX = (1 - palm.x) * window.innerWidth;
        const screenY = palm.y * window.innerHeight;
        rightCursor.style.left = screenX + 'px';
        rightCursor.style.top = screenY + 'px';
        rightCursor.style.display = 'block';
        
        const gesture = detectGesture(rightHand);
        rightCursor.classList.toggle('grabbing', gesture === 'fist' || gesture === 'pinch');
      } else {
        rightCursor.style.display = 'none';
      }

      // Draw connection line between hands
      if (leftHand && rightHand) {
        const lPalm = leftHand[9];
        const rPalm = rightHand[9];
        const lx = (1 - lPalm.x) * window.innerWidth;
        const ly = lPalm.y * window.innerHeight;
        const rx = (1 - rPalm.x) * window.innerWidth;
        const ry = rPalm.y * window.innerHeight;
        
        const length = Math.sqrt(Math.pow(rx - lx, 2) + Math.pow(ry - ly, 2));
        const angle = Math.atan2(ry - ly, rx - lx);
        
        handConnection.style.left = lx + 'px';
        handConnection.style.top = ly + 'px';
        handConnection.style.width = length + 'px';
        handConnection.style.transform = `rotate(${angle}rad)`;
        handConnection.style.display = 'block';
      } else {
        handConnection.style.display = 'none';
      }

      // Two-hand gestures
      if (leftHand && rightHand) {
        const lPalm = leftHand[0];
        const rPalm = rightHand[0];
        
        // Distance between hands for scaling
        const handDist = distance2D(lPalm, rPalm);
        target.scale = Math.max(0.3, Math.min(3, handDist * 5));
        
        // Average Y position for depth (Z)
        const avgY = (lPalm.y + rPalm.y) / 2;
        target.position.z = (0.5 - avgY) * 8;
        
        // Average X position for horizontal movement
        const avgX = (lPalm.x + rPalm.x) / 2;
        target.position.x = (0.5 - avgX) * 8;
        
        currentGesture = 'two-hands';
        gestureModeEl.textContent = 'üôå Dos manos: Escalando y moviendo';
        handStatusEl.textContent = `Escala: ${target.scale.toFixed(2)}x`;
        return;
      }

      // Single hand gestures
      const hand = leftHand || rightHand;
      if (hand) {
        const gesture = detectGesture(hand);
        const palm = hand[9];
        
        // Convert to screen space (mirrored, centered)
        const handX = (0.5 - palm.x) * 10;
        const handY = (0.5 - palm.y) * 6;
        
        switch (gesture) {
          case 'open':
            // Move galaxy
            target.position.x = handX;
            target.position.y = handY;
            currentGesture = 'move';
            gestureModeEl.textContent = '‚úã Mano abierta: Moviendo galaxia';
            break;
            
          case 'fist':
            // Rotate galaxy based on hand movement
            if (prevHandPos.left || prevHandPos.right) {
              const prev = prevHandPos.left || prevHandPos.right;
              const deltaX = palm.x - prev.x;
              const deltaY = palm.y - prev.y;
              target.rotation.y -= deltaX * 5;
              target.rotation.x -= deltaY * 3;
            }
            currentGesture = 'rotate';
            gestureModeEl.textContent = '‚úä Pu√±o: Rotando galaxia';
            break;
            
          case 'pinch':
            // Zoom based on hand Y position
            target.scale = Math.max(0.3, Math.min(3, (1 - palm.y) * 3));
            currentGesture = 'zoom';
            gestureModeEl.textContent = 'ü§è Pinza: Zoom ' + (target.scale > 1 ? 'in' : 'out');
            break;
            
          default:
            currentGesture = 'neutral';
            gestureModeEl.textContent = 'Gesto no reconocido';
        }
        
        handStatusEl.textContent = `Gesto: ${gesture}`;
        
        // Store previous position
        if (leftHand) prevHandPos.left = { ...palm };
        if (rightHand) prevHandPos.right = { ...palm };
      }
    }

    // Draw hand landmarks
    function drawHand(landmarks, idx) {
      ctx.save();
      ctx.scale(-1, 1);
      ctx.translate(-canvas.width, 0);
      
      const color = idx === 0 ? '#ff6b9d' : '#6bffb8';
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      
      const connections = [
        [0,1],[1,2],[2,3],[3,4],
        [0,5],[5,6],[6,7],[7,8],
        [0,9],[9,10],[10,11],[11,12],
        [0,13],[13,14],[14,15],[15,16],
        [0,17],[17,18],[18,19],[19,20],
        [5,9],[9,13],[13,17]
      ];
      
      connections.forEach(([i, j]) => {
        ctx.beginPath();
        ctx.moveTo(landmarks[i].x * canvas.width, landmarks[i].y * canvas.height);
        ctx.lineTo(landmarks[j].x * canvas.width, landmarks[j].y * canvas.height);
        ctx.stroke();
      });

      // Draw points
      landmarks.forEach((point, i) => {
        ctx.beginPath();
        ctx.arc(point.x * canvas.width, point.y * canvas.height, 3, 0, 2 * Math.PI);
        ctx.fillStyle = [4, 8, 12, 16, 20].includes(i) ? '#ffffff' : color;
        ctx.fill();
      });
      
      ctx.restore();
    }

    // Initialize hand tracking
    async function initHandTracking() {
      cameraBtn.classList.add('loading');
      cameraBtn.querySelector('span').textContent = 'Cargando...';

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { width: 640, height: 480, facingMode: 'user' } 
        });
        video.srcObject = stream;
        await video.play();

        handsInstance = new window.Hands({
          locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`
        });

        handsInstance.setOptions({
          maxNumHands: 2,
          modelComplexity: 1,
          minDetectionConfidence: 0.7,
          minTrackingConfidence: 0.5
        });

        handsInstance.onResults((results) => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          
          // Draw mirrored video
          ctx.save();
          ctx.scale(-1, 1);
          ctx.translate(-canvas.width, 0);
          ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
          ctx.restore();

          // Draw hands
          if (results.multiHandLandmarks) {
            results.multiHandLandmarks.forEach((landmarks, idx) => {
              drawHand(landmarks, idx);
            });
          }

          // Process gestures
          processHands(results);
        });

        cameraInstance = new window.Camera(video, {
          onFrame: async () => {
            await handsInstance.send({ image: video });
          },
          width: 640,
          height: 480
        });
        
        await cameraInstance.start();
        
        cameraActive = true;
        cameraBtn.classList.remove('loading', 'inactive');
        cameraBtn.classList.add('active');
        cameraBtn.querySelector('.camera-indicator').classList.remove('inactive');
        cameraBtn.querySelector('.camera-indicator').classList.add('active');
        cameraBtn.querySelector('span').textContent = 'Detener';
        cameraPreview.classList.add('visible');
        gestureModeEl.textContent = 'Muestra tus manos a la c√°mara';

      } catch (error) {
        console.error('Error:', error);
        handStatusEl.textContent = 'Error: ' + error.message;
        cameraBtn.classList.remove('loading');
        cameraBtn.querySelector('span').textContent = 'Iniciar C√°mara';
      }
    }

    function stopHandTracking() {
      if (cameraInstance) cameraInstance.stop();
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(track => track.stop());
      }
      
      cameraActive = false;
      cameraBtn.classList.remove('active');
      cameraBtn.classList.add('inactive');
      cameraBtn.querySelector('.camera-indicator').classList.remove('active');
      cameraBtn.querySelector('.camera-indicator').classList.add('inactive');
      cameraBtn.querySelector('span').textContent = 'Iniciar C√°mara';
      cameraPreview.classList.remove('visible');
      leftCursor.style.display = 'none';
      rightCursor.style.display = 'none';
      handConnection.style.display = 'none';
      gestureModeEl.textContent = 'Activa la c√°mara para comenzar';
      transform.autoRotate = true;
    }

    // Event Listeners
    cameraBtn.addEventListener('click', () => {
      if (cameraActive) stopHandTracking();
      else initHandTracking();
    });

    densitySlider.addEventListener('input', (e) => {
      particleCount = parseInt(e.target.value);
      densityValueEl.textContent = particleCount.toLocaleString();
      createParticles();
    });

    // Initialize
    initThreeJS();
    createParticles();
    animate();
  </script>
</body>
</html>
